# App1 - первая программа список неотложенных дел

Версия Django 4.1.4

1) Создадим проект командой: django-admin startproject superlists 

settings.py - используется для хранения глобальной конфигурационной информации о сайте.

manage.py - утилита командой строки для взаимодействия с проектом Django.

urls.py - объявление URL проекта.

2) Перейдем в директорию проекта: cd superlists

3) Запустим сервер: python manage.py runserver

4) Запускаем тест снова и видим рабочий сайт. Ссылка: localhost:8000

5) Переместим тест в папку superlists.

6) unitest - модуль для тестирования. Любая функция, которая начинается с test будет является тестом и запустится исполнителем тестов.

7) setUp и tearDown – особые методы, которые выполняются перед и после каждого теста. Я их использую для запуска и остановки браузера.

8) Запустим приложение для обработки списков неотложных дел: python manage.py startapp lists
Эта команда создаст папку в superlists/lists рядом с superlists/superlists и в
ней – несколько файлов-заготовок для таких вещей, как модели, представления и тесты, которые имеют для нас непосредственный интерес.

9) Функциональные тесты проверяют приложение с внешней стороны – с точки зрения пользователя. 
Модульные тесты проверяют приложение изнутри – с точки зрения программиста.

10) Подход TDD, которому я следую, хочет, чтобы приложение было охвачено обоими типами тестов. Поток операций будет примерно таким:

1. Мы начинаем с написания функционального теста, описывающего
новую функциональность с точки зрения пользователя.

2. Когда у нас есть функциональный тест, который не срабатывает, мы
начинаем думать о том, как написать код, который может заставить
его пройти успешно (или по крайней мере заставить перешагнуть через текущую неполадку). Мы теперь используем один или несколько
модульных тестов, чтобы выработать поведение кода, которого мы
хотим добиться. Смысл в том, что каждая строка производственного
программного кода, которую мы пишем, должна быть протестирована по крайней мере одним из наших модульных тестов.

3. Когда у нас есть неработающий модульный тест, мы пишем минимально возможный объем прикладного кода – ровно столько, чтобы
модульный тест прошел успешно. Мы можем несколько раз итеративно переключаться между шагами 2 и 3, пока не убедимся, что
функциональный тест продвинулся чуть дальше.

4. Теперь мы можем выполнить функциональные тесты повторно и
убедиться, что они проходят или продвинулись немного дальше.
Этот этап может нас побудить написать немного новых модульных
тестов и нового исходного кода и т. д.
