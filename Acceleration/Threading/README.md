# Многопоточность в Python
**Многопоточность** — это выполнение программы сразу в нескольких потоках, которые выполняют её функции одновременно.
Разница между потоками и процессами: потоки имеют общую память, поэтому изменения в одном потоке видны в других, а процессы используют разные области памяти.

**Важно:** Если решается [*CPU-bound*](https://github.com/devFF/FindJob/blob/main/Acceleration/Threading/CPU_bound.py) задача (которая потребляет только ресурсы процессора, то есть без операций ввода-вывода), то код написанный с использованием 
многопоточности будет работать медленнее, чем последовательный. Но если у нас есть операции ввода-вывода информации, то будет заметна разница в скорости выполнении кода. 
Но в задачах *I/O bound* (input/output) прирост производительности при использование потоков будет заметен.

[**Создание ограниченного пула потоков:**](https://github.com/devFF/FindJob/blob/main/Acceleration/Threading/thread_pool_example.py) Для создания ограниченного пула потоков 
удобно использовать *ThreadPoolExecutor* из модуля *concurrent.futures*. 
Аргумент *max_workers* определяет максимальное количество потоков.
При помощи удобного метода *as_completed* из модуля *concurrent.futures* мы можем дождаться 
завершения всех объектов и получить результаты по мере завершения всех созданных нами потоков.

[**Очереди и обмен данными:**](https://github.com/devFF/FindJob/blob/main/Acceleration/Threading/thread_pool_example.py) При работе с потоками рано или поздно придется обмениваться данными между ними. Использование блокировок для обмена данными сильно замедляет выполнение кода.
Поэтому для обмена данными лучше использовать очереди (модуль queue). Метод *put* помещает объект в очередь. Метод *get* позволяет получить данные из объекта. Также стоит помнить о том, что
в Python не существует функции аварийного завершения потока, поэтому создано дополнительное условие внутри функции, чтобы завершить ее выполнение. 


